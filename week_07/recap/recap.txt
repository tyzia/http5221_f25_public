Recap from Week 7
(delivered at Week 8)



Test Coverage

- Measures % of code tested.
- High coverage doesn't mean bug-free.

Testing Pyramid

- Unit Tests (functions)
- Integration Tests (modules)
- E2E Tests (whole app)

E2E Testing
Validates real user flows.
Use Cypress for automation

Install Cypress
npm init -y
npm install cypress --save-dev
npx cypress open

Cypress

Uses describe() and it() syntax
similar to Jasmine.

Always start tests by visiting
the page with cy.visit()

Element Selection:

cy.contains(text)

- cy.contains('focus link') -> finds first
element containing text (fails if not found)

cy.get(selector)

- cy.get('#username') -> by ID
- cy.get('.btn-submit') -> by class
- cy.get('input[type="text"]') -> by attribute

Interactions:

.click() - Clicks an element
.type(text) - Enters text into input fields
.clear() - Clears input fields
.submit() - Submits forms

Assertions:

.should()
.expect()
.assert()

Common .should() assertions:

.should('be.visible')
.should('have.value') -> for inputs and exact match
.should('contain') -> for DOM elements, not exact
.should('have.class')
.should('have.focus')

Best Practices:

Use beforeEach() to avoid repeating
setup code (like cy.visit())

Example

describe('Homepage Tests', () => {
    beforeEach(() => cy.visit('/'));
    it('should display the header', () => {
        cy.get('h1').should('contain', 'Welcome');
    });
    it('should have a working search bar', () => {
       cy.get('#search').type('Cypress').should('have.value', 'Cypress');
    });
});





Array methods

[1, 2, 3, 4].forEach(num => console.log(num)) -> 1, 2, 3, 4
[1, 2, 3, 4].slice(1, 3) -> [2, 3]
[1, 2, 3, 4].slice() -> [1, 2, 3, 4]
[1, 2, 3, 4].map(num => num * 2) -> [2, 4, 6, 8]
[1, 2, 3, 4].filter(num => num > 2) -> [3, 4]
[1, 2, 3, 4].some(num => num > 2) -> true
[1, 2, 3, 4].some(num => num > 4) -> false
[1, 2, 3, 4].find(num => num > 1) -> 2


Spread operator (...)

Copying
const originalArray = [1, 2, 3];
[ ...originalArray ] -> [1, 2, 3]

originalObject = { name: 'John' };
{ ...originalObject } -> { name: 'John' }

Merging
const array1 = [1, 2, 3];
const array2 = ['a', 'b', 'c'];
[ ...array1, ...array2 ] -> [1, 2, 3, 'a', 'b', 'c']

const object1 = { a: 1, b: 2 };
const object2 = { c: 3, d: 4 };
{ ...object1, ...object2 } -> { a: 1, b: 2, c: 3, d: 4 }

Passing arguments
const sum = (a, b, c) => a + b + c;
const arguments = [1, 2, 3];
sum(...arguments) -> 6



Object destructuring

const person = { name: 'Alice', age: 25, city: 'Wonderland' };
const { name, age, city } = person;

In function arguments

function greet({ name, age }) {
     console.log(`Hello, ${name}! You are ${age} years old.`);
}
const person = { name: 'Alice', age: 25, city: 'Wonderland' };
greet(person);

